---
title: "Hurdle model"
description: "Using Hurdle Likelihood for forecasting"
---

```{python}
# Disable warnings
import warnings

warnings.simplefilter(action="ignore")
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from numpyro import distributions as dist
from sktime.forecasting.compose import ForecastingPipeline
from sktime.transformations.series.fourier import FourierFeatures


from prophetverse.datasets.loaders import load_pedestrian_count
```

```{python}

import numpyro

numpyro.enable_x64()
```

## Import dataset

We use a dataset `Melbourne Pedestrian Counts` from [forecastingdata](forecastingdata.com), which contains the hourly pedestrian counts in Melbourne, Australia, from a set of sensors located in different parts of the city.

```{python}
y = load_pedestrian_count()

y[y<500] = 0
# We take only one time series for simplicity
y = y.loc["T2"]

split_index = 24 * 365
y_train, y_test = y.iloc[:split_index], y.iloc[split_index + 1 : split_index * 2 + 1]
```

Let's plot a section of the time series to see how it looks like:

```{python}
display(y_train.head())
y_train.iloc[: 24 * 21].plot(figsize=(10, 3), marker="o", color="black", legend=True)
plt.show()
```

The full dataset is actually large, and plotting it all at once does not
help a lot. Either way, let's plot the full dataset to see how it looks like:

```{python}
ax = y_train["pedestrian_count"].rename("Train").plot(figsize=(20, 7))
y_test["pedestrian_count"].rename("Test").plot(ax=ax)
ax.legend()
plt.show()
```

## Fitting models

The series has some clear patterns: a daily seasonality, a weekly seasonality, and
a yearly seasonality. It also has many zeros, and a model assuming normal
distributed observations would not be able to capture this.

First, let's fit and forecast with the standard prophet,
then see how the negative binomial model performs.

## Prophet with normal likelihood
In this case, we will see how the model will output non-sensical negative values.
The probabilistic intervals, mainly, will output values much lower than the support
of the timeseries.

```{python}
from prophetverse.effects.fourier import LinearFourierSeasonality
from prophetverse.effects.trend import FlatTrend, PiecewiseLinearTrend
from prophetverse.engine import MAPInferenceEngine
from prophetverse.engine.optimizer import CosineScheduleAdamOptimizer, LBFGSSolver
from prophetverse.effects.target.hurdle import HurdleTargetLikelihood
from prophetverse.effects.target.univariate import NormalTargetLikelihood
from prophetverse.sktime import Prophetverse
from prophetverse.utils.regex import no_input_columns
from prophetverse.effects.constant import Constant
import jax.numpy as jnp

# Here we set the prior for the seasonality effect
# And the coefficients for it
exogenous_effects = [
    (
        "seasonality",
        LinearFourierSeasonality(
            sp_list=[24, 24 * 7, 24 * 365.5],
            fourier_terms_list=[2, 2, 10],
            freq="H",
            prior_scale=0.1,
            effect_mode="multiplicative",
        ),
        no_input_columns,
    ),
    ("zero_proba__constant_term", Constant(prior=dist.Normal(0, 1)), None),
    (
        "zero_proba__seasonality",
        LinearFourierSeasonality(
            sp_list=[24],
            fourier_terms_list=[5],
            freq="H",
            prior_scale=2,
            effect_mode="additive",
        ),
        no_input_columns,
    ),
]

model = Prophetverse(
    trend=FlatTrend(),
    exogenous_effects=exogenous_effects,
    inference_engine=MAPInferenceEngine(),
    # likelihood=NormalTargetLikelihood(),
    likelihood=HurdleTargetLikelihood(likelihood_family="poisson", proba_transform=lambda x: jnp.clip(x, 0, 1)),
)
model.fit(y=y_train)
```

### Forecasting 

```{python}
forecast_horizon = y_train.index[-100:].union(y_test.index[:300])
fig, ax = plt.subplots(figsize=(10, 3))
preds_normal = model.predict(fh=forecast_horizon)
preds_normal["pedestrian_count"].rename("Normal model").plot.line(
    ax=ax, legend=False, color="tab:blue"
)
ax.scatter(y_train.index, y_train, marker="o", color="k", s=2, alpha=0.5, label="Train")
ax.scatter(
    y_test.index, y_test, marker="o", color="green", s=2, alpha=0.5, label="Test"
)
ax.set_title("Prophet with normal likelihood")
ax.legend()
fig.show()
```


```{python}

y_pred_components = model.predict_components(fh=forecast_horizon)
```

```{python}
fig, axs = plt.subplots(figsize=(10, 3), nrows=2, sharex=True)
ax = axs[0]
y_pred_components["mean"].plot.line(ax=ax)

ax.scatter(y_train.index, y_train, marker="o", color="k", s=2, alpha=0.5, label="Train")
ax.scatter(
    y_test.index, y_test, marker="o", color="green", s=2, alpha=0.5, label="Test"
)

y_pred_components["gate"].plot.line(ax=axs[1])
# y_pred_components["zero_proba__constant_term"].plot.line(ax=axs[1])
```
